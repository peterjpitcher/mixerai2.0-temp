import { NextRequest, NextResponse } from 'next/server';
import { createSupabaseAdminClient } from '@/lib/supabase/client';
import { handleApiError } from '@/lib/api-utils';
import { withAuth } from '@/lib/auth/api-auth';
import { v4 as uuidv4 } from 'uuid';
import { TablesInsert } from '@/types/supabase';

export const dynamic = "force-dynamic";

// This helper now primarily ensures new IDs and structure for table insertion.
// The actual fields to be inserted will be taken directly from sourceStep.
const prepareStepForTableInsertion = (sourceStep: any, newWorkflowId: string, stepOrder: number) => {
  return {
    // id: uuidv4(), // The workflow_steps table might have its own auto-generated ID or expect a specific format.
                     // If it's auto-generated by DB, we don't provide it.
                     // If it needs a UUID, uncomment and use uuidv4().
                     // For now, assuming DB handles it or it's not 'id' but 'step_id'
    workflow_id: newWorkflowId,
    name: sourceStep.name || 'Unnamed Step',
    step_order: stepOrder, // Crucial for maintaining order
    role: sourceStep.role || null,
    description: sourceStep.description || '',
    is_optional: typeof sourceStep.is_optional === 'boolean' ? sourceStep.is_optional : false,
    approval_required: typeof sourceStep.approval_required === 'boolean' ? sourceStep.approval_required : true,
    // assigned_user_ids: '{}', // Default to empty array of user IDs if your table uses this
    // step_id: sourceStep.step_id || uuidv4(), // If your table has a separate step_id that needs to be unique
                                            // and is different from the primary key id.
    // ... any other columns from your workflow_steps table that need to be populated
  };
};

export const POST = withAuth(async (request: NextRequest, user, context: { params: { id: string } }) => {
  const originalWorkflowId = context.params.id;

  if (!originalWorkflowId) {
    return NextResponse.json({ success: false, error: 'Original Workflow ID is required' }, { status: 400 });
  }

  const supabase = createSupabaseAdminClient();

  try {
    // 1. Fetch the original workflow
    const { data: originalWorkflow, error: fetchError } = await supabase
      .from('workflows')
      .select('*') // Still select all to get name, template_id etc.
      .eq('id', originalWorkflowId)
      .single();

    if (fetchError) {
      console.error('[API Workflows Duplicate] Error fetching original workflow:', fetchError);
      return handleApiError(fetchError, `Failed to fetch original workflow with ID: ${originalWorkflowId}`);
    }

    if (!originalWorkflow) {
      return NextResponse.json({ success: false, error: 'Original workflow not found' }, { status: 404 });
    }
    console.log('[API Workflows Duplicate] Fetched originalWorkflow. Name:', originalWorkflow.name);

    let sourceStepsData: any[] = [];

    // Try fetching from originalWorkflow.steps (JSONB) first, in case some workflows use it
    // but prioritize workflow_steps table if that's the true source of steps.
    // Based on user feedback, workflow_steps is the primary source.
    console.log('[API Workflows Duplicate] Attempting to fetch steps from workflow_steps table for original workflow.');
    const { data: stepsFromTable, error: fetchStepsTableError } = await supabase
      .from('workflow_steps')
      .select('*') // Select all relevant columns from workflow_steps
      .eq('workflow_id', originalWorkflowId)
      .order('step_order', { ascending: true });

    if (fetchStepsTableError) {
      console.error('[API Workflows Duplicate] Error fetching steps from workflow_steps table:', fetchStepsTableError);
      // Proceeding with empty steps if fetch fails, but log it.
    } else if (stepsFromTable && stepsFromTable.length > 0) {
      console.log(`[API Workflows Duplicate] Fetched ${stepsFromTable.length} steps from workflow_steps table.`);
      sourceStepsData = stepsFromTable;
    } else {
      console.log('[API Workflows Duplicate] No steps found in workflow_steps table for the original workflow.');
      // Fallback: Check the JSONB column, though user says it's not used.
      if (originalWorkflow.steps && Array.isArray(originalWorkflow.steps) && originalWorkflow.steps.length > 0) {
        console.log('[API Workflows Duplicate] Fallback: Using steps from originalWorkflow.steps JSONB column.');
        sourceStepsData = originalWorkflow.steps;
      } else {
        console.log('[API Workflows Duplicate] No steps found in JSONB column either.');
      }
    }
    
    // 2. Create the new workflow shell (without steps in JSONB)
    const newWorkflowShellData: TablesInsert<'workflows'> = {
      name: `Copy of ${originalWorkflow.name}`,
      brand_id: null,
      template_id: null, // originalWorkflow.template_id if you want to copy it
      status: 'draft',
      created_by: user.id,
      steps: [], // Explicitly set to empty array or null if column allows
                  // to ensure we don't use the JSONB steps field for this new workflow.
    };
    console.log('[API Workflows Duplicate] newWorkflowShellData to insert:', JSON.stringify(newWorkflowShellData, null, 2));

    const { data: newWorkflow, error: insertWorkflowError } = await supabase
      .from('workflows')
      .insert(newWorkflowShellData)
      .select()
      .single();

    if (insertWorkflowError) {
      console.error('[API Workflows Duplicate] Error inserting new workflow shell:', insertWorkflowError);
      return handleApiError(insertWorkflowError, 'Failed to create new workflow shell');
    }

    if (!newWorkflow || !newWorkflow.id) {
      console.error('[API Workflows Duplicate] Failed to create new workflow shell or get its ID.');
      return NextResponse.json({ success: false, error: 'Failed to create new workflow record or retrieve its ID.' }, { status: 500 });
    }
    console.log('[API Workflows Duplicate] Successfully created new workflow shell. ID:', newWorkflow.id);

    // 3. If there are steps to duplicate, prepare and insert them into workflow_steps table
    if (sourceStepsData.length > 0) {
      console.log(`[API Workflows Duplicate] Preparing to insert ${sourceStepsData.length} steps into workflow_steps for new workflow ID: ${newWorkflow.id}`);
      
      const newStepRowsForTable = sourceStepsData.map((step, index) => 
        prepareStepForTableInsertion(step, newWorkflow.id, index + 1) // index + 1 for step_order
      );
      
      console.log('[API Workflows Duplicate] New step rows for workflow_steps table:', JSON.stringify(newStepRowsForTable, null, 2));

      const { error: insertStepsError } = await supabase
        .from('workflow_steps')
        .insert(newStepRowsForTable);

      if (insertStepsError) {
        console.error('[API Workflows Duplicate] Error inserting new steps into workflow_steps table:', insertStepsError);
        // This is a critical error. We might want to consider rolling back the workflow shell creation
        // or marking it as incomplete. For now, returning an error.
        return handleApiError(insertStepsError, 'Failed to insert steps for the new workflow. The workflow shell was created, but steps are missing.');
      }
      console.log(`[API Workflows Duplicate] Successfully inserted ${newStepRowsForTable.length} steps into workflow_steps table.`);
    } else {
      console.log('[API Workflows Duplicate] No source steps found to duplicate into workflow_steps table.');
    }
    
    // 4. Fetch the complete new workflow data (if needed, or just return the shell + success)
    // For consistency, it's good to return the created workflow object.
    // Since steps are not in the JSONB, newWorkflow object might be sufficient as is.
    return NextResponse.json({ success: true, workflow: newWorkflow });

  } catch (error: any) {
    console.error('[API Workflows Duplicate] General error:', error);
    return handleApiError(error, 'An unexpected error occurred while duplicating the workflow');
  }
}); 